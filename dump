#!/usr/bin/env bash
#
# command line trash uitility
#
# @params
# Globals
#   DUMP_DIR: location to store trash
#   DUMP_LOG: file to record all dumps
#   action_comand: function to execute
#   DUMP_CONFIRM: skip confirmation
# Arguments
#   --regret: revert a dump
#   --put: put a file to dump
#   --clean: clean all dumps
#   --log: see all dumped files

set -e
set -f

DUMP_DIR="${DUMP_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}}/dump/trash"
DUMP_LOG="${DUMP_LOG:-${XDG_DATA_HOME:-$HOME/.local/share}}/dump/log"

[[ ! -d "${DUMP_DIR}" ]] && mkdir -p "${DUMP_DIR}"

#######################################
# get user confirmation
# Arguments:
#   $1: prompt to display to user
# Outputs:
#   y/n: out put either y or n as user confirm status
#######################################
function get_confirm() {
  local confirm
  local message="${1:-Confirm?}"
  while [ "${confirm}" != 'y' ]  && [ "${confirm}" != 'n' ]; do
    read -r -p "${message}(y/n): " confirm
  done
  echo "${confirm}"
}

#######################################
# put a file dump
# Arguments:
#   $*: all the command line argument are parsed as files to remove
# Example:
#   put foo.txt boo.txt
#######################################
function put() {
  local files_to_remove=("$@") esc candidates=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ "${#files_to_remove[@]}" -eq 0 ]]; then
    esc=$(printf '\033')
    while IFS= read -r line; do
      candidates+=("${esc}[34m${line}/${esc}[m")
    done < <(fd --type d -d 1)
    while IFS= read -r line; do
      candidates+=("${line}")
    done < <(fd --type f -d 1)

    while IFS= read -r line; do
      files_to_remove+=("${line}")
    done < <(
      IFS=$'\n'
      echo "${candidates[*]}" \
        | fzf --ansi --exit-0 --multi
    )
  fi

  [[ "${#files_to_remove[@]}" -eq 0 ]] && exit 1
  [[ -z "${DUMP_CONFIRM}" ]] && \
    DUMP_CONFIRM=$(get_confirm "put: confirm dump?")
  [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
  for file in "${files_to_remove[@]}"; do
    mv -v "${file}" "${DUMP_DIR}"/
    sed -i '' "s|${file}: $PWD/${file}||g" "${DUMP_LOG}"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    echo "${file}: $PWD/${file}" >> "${DUMP_LOG}"
  done
}

#######################################
# regret a file, move a file from dump to 
# it's orignal location
# Arguments:
#   -y|--yes: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function regret() {
  local files_removed=() file_name file_to_revert fuzzy files_to_revert=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ -n "${fuzzy}" ]]; then
    while IFS= read -r line; do
      files_to_revert+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi)
    [[ "${#file_to_revert[@]}" -eq 0 ]] && exit 1
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "regret: reset selected dumps to orignal location?")
    [[ "${DUMP_CONFIRM}" != 'y' ]] && exit 1
    for file in "${files_to_revert[@]}"; do
      file_name="${file%%: *}"
      if [[ -f "${DUMP_DIR}/${file_name}" ]] || [[ -d "${DUMP_DIR}/${file_name}" ]]; then
        mv -v "${DUMP_DIR}"/"${file_name}" "${file##*: }"
        sed -i '' "s|${file}||g" "${DUMP_LOG}"
        sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
      fi
    done

  else
    while IFS= read -r line; do
      file_name="${line%%: *}"
      if [[ -f "${DUMP_DIR}/${file_name}" ]] || [[ -d "${DUMP_DIR}/${file_name}" ]]; then
        [[ -z "${file_to_revert}" ]] && \
          file_to_revert="${line}" || \
          files_removed+=("${line}")
      fi
    done < <(tac "${DUMP_LOG}")
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "regret: reset ${file_to_revert%%: *} to ${file_to_revert##*: }?")
    [[ "${DUMP_CONFIRM}" != 'y' ]] && exit 1
    printf "%s\n" "${files_removed[@]}" | tac > "${DUMP_LOG}"
    [[ -n "${file_to_revert}" ]] && \
      mv -v "${DUMP_DIR}/${file_to_revert%%: *}" "${file_to_revert##*: }"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
  fi
}

#######################################
# clean the dump folder and log
# Arguments:
#   -y|--yes: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function clean() {
  local fuzzy files_to_clean=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ -z "${fuzzy}" ]]; then
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "clean: delete all dumps?")
    [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
    rm -vrf "${DUMP_DIR}"
    truncate -s 0 "${DUMP_LOG}"

  else
    while IFS= read -r line; do
      files_to_clean+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi)
    [[ "${#files_to_clean[@]}" -eq 0 ]] && exit 1
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "clean: delete selected dumps?")
    [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
    for file in "${files_to_clean[@]}"; do
      file_name="${file%%: *}"
      if [[ -f "${DUMP_DIR}/${file_name}" ]] || [[ -d "${DUMP_DIR}/${file_name}" ]]; then
        rm -vrf "${DUMP_DIR}/${file_name}"
        sed -i '' "s|${file}||g" "${DUMP_LOG}"
        sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
      fi
    done
  fi
}

#######################################
# using a pager to list all dumps
# Arguments:
#   None
#######################################
function log() {
  tac "${DUMP_LOG}" \
    | awk -F ":" '
        BEGIN { printf "%-31s %-40s\n", "Name", "Location" }
        { printf "%-30s %-40s\n", $1, $2}
      ' \
    | less
}

action_comand="put"
case $1 in
  --put|-p)
    action_comand="put"
    shift
    ;;
  --clean|-c)
    action_comand="clean"
    shift
    ;;
  --regret|-r)
    action_comand='regret'
    shift
    ;;
  --log|-l)
    action_comand='log'
    shift
    ;;
esac

eval "${action_comand}" "$*"
