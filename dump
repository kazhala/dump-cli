#!/usr/bin/env bash
#
# command line trash utility
#
# @params
# Globals
#   DUMP_DIR: location to store trash
#   DUMP_LOG: file to record all dumps
#   action_comand: function to execute
#   DUMP_CONFIRM: skip confirmation
# Arguments
#   --regret: revert a dump
#   --put: put a file to dump
#   --clean: clean all dumps
#   --log: see all dumped files

set -e

DUMP_DIR="${DUMP_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/dump/trash}"
DUMP_LOG="${DUMP_LOG:-${XDG_DATA_HOME:-$HOME/.local/share}/dump/log}"

[[ ! -d "${DUMP_DIR}" ]] && mkdir -p "${DUMP_DIR}"
[[ ! -f "${DUMP_LOG}" ]] && touch "${DUMP_LOG}"

#######################################
# get user confirmation
# Arguments:
#   $1: prompt to display to user
# Outputs:
#   y/n: out put either y or n as user confirm status
#######################################
function get_confirm() {
  local confirm
  local message="${1:-Confirm?}"
  while [ "${confirm}" != 'y' ]  && [ "${confirm}" != 'n' ]; do
    read -r -p "${message}(y/n): " confirm
  done
  echo "${confirm}"
}

#######################################
# put a file dump
# Arguments:
#   -y|--yes: skip confirmation
#   $*: all the command line argument are parsed as files to remove
# Example:
#   dump --put foo.txt boo.txt
#######################################
function put() {
  local files_to_remove=("$@") esc candidates=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ "${#files_to_remove[@]}" -eq 0 ]]; then
    esc=$(printf '\033')
    while IFS= read -r line; do
      candidates+=("${esc}[34m${line}/${esc}[m")
    done < <(find -s . -maxdepth 1 -mindepth 1 -type d -exec basename {} +)
    while IFS= read -r line; do
      candidates+=("${line}")
    done < <(find -s . -maxdepth 1 -mindepth 1 -type f -exec basename {} +)

    while IFS= read -r line; do
      files_to_remove+=("${line}")
    done < <(
      IFS=$'\n'
      echo "${candidates[*]}" \
        | fzf --ansi --exit-0 --multi --exit-0
    )
  fi

  [[ "${#files_to_remove[@]}" -eq 0 ]] && exit 1
  [[ -z "${DUMP_CONFIRM}" ]] && \
    DUMP_CONFIRM=$(get_confirm "put: confirm dump?")
  [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
  for file in "${files_to_remove[@]}"; do
    mv -v "${file}" "${DUMP_DIR}"/
    sed -i '' "s|${file##*/}: $PWD/${file}||g" "${DUMP_LOG}"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    echo "${file##*/}: $PWD/${file}" >> "${DUMP_LOG}"
  done
}

#######################################
# regret(undo) a file, move a file from dump to it's original location
# Arguments:
#   -y|--yes: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function regret() {
  local files_removed=() file_name file_to_revert fuzzy files_to_revert=() 
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        for file in "$@"; do
          files_to_revert+=("${file}")
        done
        break
        ;;
    esac
  done

  if [[ "${#files_to_revert[@]}" -gt 0 ]]; then
    for file in "${files_to_revert[@]}"; do
      file_to_revert=$(grep -xE "^$file:\s.*$" "${DUMP_LOG}")
      [[ -z "${file_to_revert}" ]] \
        && echo "File not found in dump log" \
        && continue
      mv -v "${DUMP_DIR}"/"${file_to_revert%%: *}" "${file_to_revert##*: }"
      sed -i '' "s|${file_to_revert}||g" "${DUMP_LOG}"
      sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    done

  elif [[ -n "${fuzzy}" ]]; then
    while IFS= read -r line; do
      files_to_revert+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi --exit-0)
    [[ "${#files_to_revert[@]}" -eq 0 ]] && exit 1
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "regret: reset selected dumps to original location?")
    [[ "${DUMP_CONFIRM}" != 'y' ]] && exit 1
    for file in "${files_to_revert[@]}"; do
      file_name="${file%%: *}"
      if find "${DUMP_DIR}/${file_name}" &>/dev/null; then
        mv -v "${DUMP_DIR}"/"${file_name}" "${file##*: }"
        sed -i '' "s|${file}||g" "${DUMP_LOG}"
        sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
      fi
    done

  else
    while IFS= read -r line; do
      file_name="${line%%: *}"
      if find "${DUMP_DIR}/${file_name}" &>/dev/null; then
        [[ -z "${file_to_revert}" ]] && \
          file_to_revert="${line}" || \
          files_removed+=("${line}")
      fi
    done < <(tac "${DUMP_LOG}")
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "regret: reset ${file_to_revert%%: *} to ${file_to_revert##*: }?")
    [[ "${DUMP_CONFIRM}" != 'y' ]] && exit 1
    printf "%s\n" "${files_removed[@]}" | tac > "${DUMP_LOG}"
    [[ -n "${file_to_revert}" ]] && \
      mv -v "${DUMP_DIR}/${file_to_revert%%: *}" "${file_to_revert##*: }"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
  fi
}

#######################################
# clean the dump folder and log
# Arguments:
#   -y|--yes: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function clean() {
  local fuzzy files_to_clean=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        echo "Invalid option $1" 1>&2
        exit 1
        ;;
    esac
  done

  if [[ -z "${fuzzy}" ]]; then
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "clean: delete all dumps?")
    [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
    rm -vrf "${DUMP_DIR:?}"/{*,.*??}
    truncate -s 0 "${DUMP_LOG}"

  else
    while IFS= read -r line; do
      files_to_clean+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi --exit-0)
    [[ "${#files_to_clean[@]}" -eq 0 ]] && exit 1
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "clean: delete selected dumps?")
    [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
    for file in "${files_to_clean[@]}"; do
      file_name="${file%%: *}"
      rm -vrf "${DUMP_DIR:?}/${file_name}"
      sed -i '' "s|${file}||g" "${DUMP_LOG}"
      sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    done
  fi
}

#######################################
# using a pager to list all dumps
#######################################
function log() {
  tac "${DUMP_LOG}" \
    | awk -F ":" '
        BEGIN { printf "%-31s %-40s\n", "Name", "Location" }
        { printf "%-30s %-40s\n", $1, $2}
      ' \
    | less
}

#######################################
# print usage of dump-cli
#######################################
function usage() {
  echo -e "Usage: dump [-h] [-p] [-c] [-r] [-l] [FILES] [OPTIONS] ...

A simple to use trash utility which persist the dumped file and it's original
location for future undos. Integrated with fzf for interactive selection of the
file to undo.

Optional arguments:
  -h, --help\t\tshow this help message and exit.
  -p FILE, --put FILE\tdump files to trash location.
  -c, --clean\t\tclean up trash location.
  -r, --regret\t\tundo removed files from trash location.
  -l, --log\t\tdisplay the trash log.

--put:
  -y, --yes\t\tskip confirmation.

--regret:
  -y, --yes\t\tskip confirmation.
  -s, --select\t\tselect a file to undo.



"
}


action_comand="put"
case $1 in
  --help|-h)
    usage
    exit 0
    ;;
  --put|-p)
    action_comand="put"
    shift
    ;;
  --clean|-c)
    action_comand="clean"
    shift
    ;;
  --regret|-r)
    action_comand='regret'
    shift
    ;;
  --log|-l)
    action_comand='log'
    shift
    ;;
esac

"${action_comand}" "$@"
