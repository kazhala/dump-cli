#!/usr/bin/env bash
#
# command line trash utility
#
# @params
# Globals
#   DUMP_DIR: location to store trash
#   DUMP_LOG: file to record all dumps
#   action_comand: function to execute
# Arguments
#   --regret: revert a dump
#   --put: put a file to dump
#   --clean: clean all dumps
#   --log: see all dumped files

set -e

DUMP_DIR="${DUMP_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/dump/trash}"
DUMP_LOG="${DUMP_LOG:-${XDG_DATA_HOME:-$HOME/.local/share}/dump/log}"

[[ ! -d "${DUMP_DIR}" ]] && mkdir -p "${DUMP_DIR}"
[[ ! -f "${DUMP_LOG}" ]] && touch "${DUMP_LOG}"

#######################################
# get user confirmation
# Arguments:
#   $1: prompt to display to user
# Outputs:
#   y/n: out put either y or n as user confirm status
#######################################
function get_confirm() {
  local confirm
  local message="${1:-Confirm?}"
  while [[ "${confirm}" != 'y' ]] && [[ "${confirm}" != 'n' ]]; do
    read -r -p "${message}(y/n): " confirm
  done
  echo "${confirm}"
}

#######################################
# put a file dump
# Arguments:
#   -h|--help: show help message and exit
#   -i|--confirm: prompt confirmation on each file
#   $*: all the no flag command line argument are parsed as files to remove
# Example:
#   dump --put foo.txt boo.txt
#######################################
function put() {
  local files_to_remove=("$@") esc candidates=() confirm_prompt confirm_result
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      -i|--confirm)
        confirm_prompt="true"
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ "${#files_to_remove[@]}" -eq 0 ]]; then
    esc=$(printf '\033')
    while IFS= read -r line; do
      candidates+=("${esc}[34m${line}/${esc}[m")
    done < <(find -s . -maxdepth 1 -mindepth 1 -type d -exec basename {} +)
    while IFS= read -r line; do
      candidates+=("${line}")
    done < <(find -s . -maxdepth 1 -mindepth 1 -type f -exec basename {} +)

    while IFS= read -r line; do
      files_to_remove+=("${line}")
    done < <(
      IFS=$'\n'
      echo "${candidates[*]}" \
        | fzf --ansi --exit-0 --multi --exit-0
    )
  fi

  [[ "${#files_to_remove[@]}" -eq 0 ]] && exit 1
  for file in "${files_to_remove[@]}"; do
    [[ -n "${confirm_prompt}" ]] \
      && confirm_result=$(get_confirm "put: dump ${file}?") \
      && [[ "${confirm_result}" != "y" ]] \
      && continue
    mv -v "${file}" "${DUMP_DIR}"/
    sed -i '' "s|${file##*/}: $PWD/${file}||g" "${DUMP_LOG}"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    echo "${file##*/}: $PWD/${file}" >> "${DUMP_LOG}"
  done
}

#######################################
# regret(undo) a file, move a file from dump to it's original location
# Arguments:
#   -h|--help: show help message and exit
#   -i|--confirm: prompt confirmation on each file
#   -s|--select: use fzf to select a file to revert
#   $*: all the no flag command line argument are parsed as files to regret
#######################################
function regret() {
  local file_to_revert fuzzy files_to_revert=() confirm_prompt confirm_result
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      -y|--yes)
        confirm_prompt="true"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        for file in "$@"; do
          files_to_revert+=("${file}")
        done
        break
        ;;
    esac
  done

  _move_file() {
    local file_name file_path file_line
    file_line="$1"
    file_name="${file_line%%: *}"
    file_path="${file_line##*: }"
    [[ -n "${confirm_prompt}" ]] \
      && confirm_result=$(get_confirm "put: dump ${file}?") \
      && [[ "${confirm_result}" != "y" ]] \
      && return
    sed -i '' "s|${file_to_revert}||g" "${DUMP_LOG}"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    [[ ! -d "${file_path%/*}" ]] \
      && mkdir -p "${file_path%/*}"
    mv -v "${DUMP_DIR}"/"${file_name}" "${file_path}"
  }

  if [[ "${#files_to_revert[@]}" -gt 0 ]]; then
    for file in "${files_to_revert[@]}"; do
      file_to_revert=$(grep -xE "^$file:\s.*$" "${DUMP_LOG}")
      [[ -z "${file_to_revert}" ]] \
        && echo "File not found in dump log" \
        && continue
      _move_file "${file_to_revert}"
    done

  elif [[ -n "${fuzzy}" ]]; then
    while IFS= read -r line; do
      files_to_revert+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi --exit-0)
    [[ "${#files_to_revert[@]}" -eq 0 ]] && exit 1
    [[ "${DUMP_CONFIRM}" != 'y' ]] && exit 1
    for file_to_revert in "${files_to_revert[@]}"; do
      _move_file "${file_to_revert}"
    done

  else
    file_to_revert=$(tail -r -n 1 "${DUMP_LOG}")
    [[ -z "${file_to_revert}" ]] \
      && echo "No file to reset" \
      && exit 1
    _move_file "${file_to_revert}"
  fi
}

#######################################
# clean the dump folder and log
# Arguments:
#   -y|--yes: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function clean() {
  local fuzzy files_to_clean=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        DUMP_CONFIRM="y"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        echo "Invalid option $1" 1>&2
        exit 1
        ;;
    esac
  done

  if [[ -z "${fuzzy}" ]]; then
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "clean: delete all dumps?")
    [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
    rm -vrf "${DUMP_DIR:?}"/{*,.*??}
    truncate -s 0 "${DUMP_LOG}"

  else
    while IFS= read -r line; do
      files_to_clean+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi --exit-0)
    [[ "${#files_to_clean[@]}" -eq 0 ]] && exit 1
    [[ -z "${DUMP_CONFIRM}" ]] && \
      DUMP_CONFIRM=$(get_confirm "clean: delete selected dumps?")
    [[ "${DUMP_CONFIRM}" == 'n' ]] && exit 1
    for file in "${files_to_clean[@]}"; do
      file_name="${file%%: *}"
      rm -vrf "${DUMP_DIR:?}/${file_name}"
      sed -i '' "s|${file}||g" "${DUMP_LOG}"
      sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    done
  fi
}

#######################################
# using a pager to list all dumps
#######################################
function log() {
  tac "${DUMP_LOG}" \
    | awk -F ":" '
        BEGIN { printf "%-31s %-40s\n", "Name", "Location" }
        { printf "%-30s %-40s\n", $1, $2}
      ' \
    | less
}

#######################################
# print usage of dump-cli
#######################################
function usage() {
  echo -e "Usage: dump [-h] [-p] [-c] [-r] [-l] [FILES] [OPTIONS] ...

A simple to use trash utility which persist the dumped file and it's original
location for future undos. Integrated with fzf for interactive selection of the
file to undo.

Optional arguments:
  -h, --help\t\tshow this help message and exit.
  -p FILE, --put FILE\tdump files to trash location.
  -c, --clean\t\tclean up trash location.
  -r, --regret\t\tundo removed files from trash location.
  -l, --log\t\tdisplay the trash log.

--put [FILE]:

  dump files to ${DUMP_DIR}

  Optional arguments:
    -i, --confirm\t\tprompt confirmation before dumping each file.

--regret [FILE]:

  undo files from "${DUMP_DIR}"

  Optional arguments:
    -i, --confirm\t\tprompt confirmation before dumping each file.
    -s, --select\t\tselect a file to undo."
}


action_comand="put"
case $1 in
  --help|-h)
    usage
    exit 0
    ;;
  --put|-p)
    action_comand="put"
    shift
    ;;
  --clean|-c)
    action_comand="clean"
    shift
    ;;
  --regret|-r)
    action_comand='regret'
    shift
    ;;
  --log|-l)
    action_comand='log'
    shift
    ;;
esac

"${action_comand}" "$@"
