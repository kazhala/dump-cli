#!/usr/bin/env bash
#
# command line trash utility
#
# @params
# Globals
#   DUMP_DIR: location to store trash
#   DUMP_LOG: file to record all dumps
#   action_comand: function to execute
# Arguments
#   -r|--regret: revert a dump
#   -p|--put: put a file to dump
#   -c|--clean: clean all dumps
#   -l|--log: see all dumped files
#   -h|--help: show help and exit

set -e

DUMP_DIR="${DUMP_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/dump/trash}"
DUMP_LOG="${DUMP_LOG:-${XDG_DATA_HOME:-$HOME/.local/share}/dump/log}"

[[ ! -d "${DUMP_DIR}" ]] && mkdir -p "${DUMP_DIR}"
[[ ! -f "${DUMP_LOG}" ]] && touch "${DUMP_LOG}"

#######################################
# get user confirmation
# Arguments:
#   $1: prompt to display to user
# Outputs:
#   y/n: out put either y or n as user confirm status
#######################################
function get_confirm() {
  local confirm
  local message="${1:-Confirm?}"
  while [[ "${confirm}" != 'y' ]] && [[ "${confirm}" != 'n' ]]; do
    read -r -p "${message}(y/n): " confirm
  done
  echo "${confirm}"
}

#######################################
# put a file dump
# Arguments:
#   -h|--help: show help message and exit
#   -i|--confirm: prompt confirmation on each file
#   $*: all the no flag command line argument are parsed as files to remove
# Example:
#   dump --put foo.txt boo.txt
#######################################
function put() {
  local files_to_remove=() esc candidates=() confirm_prompt confirm_result fuzzy
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      -i|--confirm)
        confirm_prompt="true"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        files_to_remove=("$@")
        break
        ;;
    esac
  done

  if [[ -n "${fuzzy}" ]]; then
    esc=$(printf '\033')
    while IFS= read -r line; do
      candidates+=("${esc}[34m${line}/${esc}[m")
    done < <(find -s . -maxdepth 1 -mindepth 1 -type d -exec basename {} +)
    while IFS= read -r line; do
      candidates+=("${line}")
    done < <(find -s . -maxdepth 1 -mindepth 1 -type f -exec basename {} +)

    while IFS= read -r line; do
      files_to_remove+=("${line}")
    done < <(
      IFS=$'\n'
      echo "${candidates[*]}" \
        | fzf --ansi --exit-0 --multi --exit-0
    )
  fi

  [[ "${#files_to_remove[@]}" -eq 0 ]] && exit 1

  for file in "${files_to_remove[@]}"; do
    [[ -n "${confirm_prompt}" ]] \
      && confirm_result=$(get_confirm "put: dump ${file} to ${DUMP_DIR}/${file##*/}?") \
      && [[ "${confirm_result}" != "y" ]] \
      && continue
    mv -v "${file}" "${DUMP_DIR}"/
    sed -i '' "s|${file##*/}: $PWD/${file}||g" "${DUMP_LOG}"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    echo "${file##*/}: $PWD/${file}" >> "${DUMP_LOG}"
  done
}

#######################################
# regret(undo) a file, move a file from dump to it's original location
# Arguments:
#   -h|--help: show help message and exit
#   -i|--confirm: prompt confirmation on each file
#   -s|--select: use fzf to select a file to revert
#   -l|--local: reset file to current location
#   $*: all the no flag command line argument are parsed as files to regret
#######################################
function regret() {
  local file_to_revert fuzzy confirm_prompt confirm_result regret_location files_to_revert
  files_to_revert=()
  regret_location="original"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -l|--local)
        regret_location="local"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      -i|--confirm)
        confirm_prompt="true"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        files_to_revert=("$@")
        break
        ;;
    esac
  done

  _move_file() {
    local file_name file_path file_line
    file_line="$1"
    file_name="${file_line%%: *}"

    case "${regret_location}" in
      "original")
        file_path="${file_line##*: }"
        ;;
      "local")
        file_path="$PWD"
        ;;
      *)
        file_path="${file_line##*: }"
        ;;
    esac

    [[ -n "${confirm_prompt}" ]] \
      && confirm_result=$(get_confirm "regret: reset ${file_name} to ${file_path}?") \
      && [[ "${confirm_result}" != "y" ]] \
      && return
    sed -i '' "s|${file_line}||g" "${DUMP_LOG}"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
    [[ ! -d "${file_path%/*}" ]] \
      && mkdir -p "${file_path%/*}"
    mv -v "${DUMP_DIR}"/"${file_name}" "${file_path}"
  }

  if [[ "${#files_to_revert[@]}" -gt 0 ]]; then
    for file in "${files_to_revert[@]}"; do
      file_to_revert=$(grep -xE "^$file:\s.*$" "${DUMP_LOG}" | tail -r -n 1)
      [[ -z "${file_to_revert}" ]] \
        && echo "File not found in dump log" \
        && continue
      _move_file "${file_to_revert}"
    done

  elif [[ -n "${fuzzy}" ]]; then
    while IFS= read -r line; do
      files_to_revert+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi --exit-0)
    [[ "${#files_to_revert[@]}" -eq 0 ]] && exit 1
    for file_to_revert in "${files_to_revert[@]}"; do
      _move_file "${file_to_revert}"
    done

  else
    file_to_revert=$(tail -r -n 1 "${DUMP_LOG}")
    [[ -z "${file_to_revert}" ]] \
      && echo "No file to reset" \
      && exit 1
    _move_file "${file_to_revert}"
  fi
}

#######################################
# clean the dump folder and log
# Arguments:
#   -y|--yes: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function clean() {
  local fuzzy files_to_clean file_to_clean confirm_prompt confirm_result file_path file_name
  files_to_clean=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--confirm)
        confirm_prompt="true"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
      *)
        files_to_clean=("$@")
        break
        ;;
    esac
  done

  if [[ "${#files_to_clean[@]}" -gt 0 ]]; then
    for file in "${files_to_clean[@]}"; do
      file_to_clean=$(grep -xE "^$file:\s.*$" "${DUMP_LOG}" | tail -r -n 1)
      file_name="${file_to_clean%%: *}"
      file_path="${file_to_clean##*: }"
      [[ -z "${files_to_clean}" ]] \
        && echo "File not found in dump log" \
        && continue
      [[ -n "${confirm_prompt}" ]] \
        && confirm_result=$(get_confirm "clean: permanently delete ${file_name}?") \
        && [[ "${confirm_result}" != "y" ]] \
        && exit 0
      sed -i '' "s|${file_to_clean}||g" "${DUMP_LOG}"
      sed -i '' "/^[[:space:]]*$/d" "${DUMP_LOG}"
      rm -vrf "${DUMP_DIR:?}/${file_name}"
    done

  elif [[ -n "${fuzzy}" ]]; then
    [[ -n "${confirm_prompt}" ]] \
      && confirm_result=$(get_confirm "clean: permanently delete all dumps?") \
      && [[ "${confirm_result}" != "y" ]] \
      && exit 0
    rm -vrf "${DUMP_DIR:?}"/{*,.*??}
    truncate -s 0 "${DUMP_LOG}"

  else
    while IFS= read -r line; do
      files_to_clean+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi --exit-0)
    [[ "${#files_to_clean[@]}" -eq 0 ]] && exit 1
    for file in "${files_to_clean[@]}"; do
      file_name="${file%%: *}"
      [[ -n "${confirm_prompt}" ]] \
        && confirm_result=$(get_confirm "clean: permanently delete ${file_name}?") \
        && [[ "${confirm_result}" != "y" ]] \
        && continue
      sed -i '' "s|${file}||g" "${DUMP_LOG}"
      sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
      rm -vrf "${DUMP_DIR:?}/${file_name}"
    done
  fi
}

#######################################
# using a pager to list all dumps
#######################################
function log() {
  tac "${DUMP_LOG}" \
    | awk -F ":" '
        BEGIN { printf "%-31s %-40s\n", "Name", "Location" }
        { printf "%-30s %-40s\n", $1, $2}
      ' \
    | less
}

#######################################
# print usage of dump-cli
#######################################
function usage() {
  echo -e "Usage: dump [-h] [-p] [-c] [-r] [-l] [FILE] [OPTIONS] ...

A simple to use trash utility which persist the dumped file and it's original
location for future undos. Integrated with fzf for interactive selection of the
file to undo.

Optional arguments:
  -h, --help\t\tshow this help message and exit.
  -p , --put\t\tdump files to trash location.
  -c, --clean\t\tclean up trash location.
  -r, --regret\t\tundo removed files from trash location.
  -l, --log\t\tdisplay the trash log.


--put [FILE]:

  dump files to ${DUMP_DIR}

  Optional arguments:
    -i, --confirm\t\tprompt confirmation before dumping each file.
    -s, --select\t\tselect a file to delete through fzf.

  Example:
    dump --put hello.py hello.java src/* bin
    dump --put --select


--regret [FILE]:

  undo files from ${DUMP_DIR}

  Optional arguments:
    -i, --confirm\t\tprompt confirmation before dumping each file.
    -s, --select\t\tselect a file to undo through fzf.
    -l, --local\t\treset file to current location.

  Example:
    dump --regret hello.java hello.py bin
    dump --regret --select

--clean [FILE]:

  permanently remove files from ${DUMP_DIR}

  Optional arguments:
    -"
}


action_comand="put"
case $1 in
  --help|-h)
    usage
    exit 0
    ;;
  --put|-p)
    action_comand="put"
    shift
    ;;
  --clean|-c)
    action_comand="clean"
    shift
    ;;
  --regret|-r)
    action_comand='regret'
    shift
    ;;
  --log|-l)
    action_comand='log'
    shift
    ;;
esac

"${action_comand}" "$@"
