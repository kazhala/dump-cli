#!/usr/bin/env bash
#
# command line trash uitility
#
# @params
# Globals
#   DUMP_DIR: location to store trash
#   DUMP_LOG: file to record all dumps
#   action_comand: function to execute
# Arguments
#   --regret: revert a dump
#   --put: put a file to dump
#   --clean: clean all dumps
#   --log: see all dumped files

set -e
set -f

DUMP_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/dump/trash"
DUMP_LOG="${XDG_DATA_HOME:-$HOME/.local/share}/dump/log"

[[ ! -d "${DUMP_DIR}" ]] && mkdir -p "${DUMP_DIR}"

#######################################
# get user confirmation
# Arguments:
#   $1: prompt to display to user
# Outputs:
#   y/n: out put either y or n as user confirm status
#######################################
function get_confirm() {
  local confirm
  local message="${1:-Confirm?}"
  while [ "${confirm}" != 'y' ]  && [ "${confirm}" != 'n' ]; do
    read -r -p "${message}(y/n): " confirm
  done
  echo "${confirm}"
}

#######################################
# put a file dump
# Arguments:
#   $*: all the command line argument are parsed as files to remove
# Example:
#   put foo.txt boo.txt
#######################################
function put() {
  local files_to_remove=("$@") esc candidates=()
  if [[ "${#files_to_remove[@]}" -eq 0 ]]; then
    esc=$(printf '\033')
    while IFS= read -r line; do
      candidates+=("${esc}[34m${line}/${esc}[m")
    done < <(fd --type d -d 1)
    while IFS= read -r line; do
      candidates+=("${line}")
    done < <(fd --type f -d 1)

    while IFS= read -r line; do
      files_to_remove+=("${line}")
    done < <(
      IFS=$'\n'
      echo "${candidates[*]}" \
        | fzf --ansi --exit-0 --multi
    )
  fi
  for file in "${files_to_remove[@]}"; do
    mv -v "${file}" "${DUMP_DIR}"/
    echo "${file}: $PWD/${file}" >> "${DUMP_LOG}"
  done
}

#######################################
# regret a file, move a file from dump to 
# it's orignal location
# Arguments:
#   -y|--confirm: proceed without confirm prompt
#   -s|--select: use fzf to select a file to revert
#######################################
function regret() {
  local files_removed=() file_name file_to_revert confirm fuzzy files_to_revert=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--confirm)
        confirm="y"
        shift
        ;;
      -s|--select)
        fuzzy="true"
        shift
        ;;
    esac
  done

  if [[ -n "${fuzzy}" ]]; then
    while IFS= read -r line; do
      files_to_revert+=("${line}")
    done < <(tac "${DUMP_LOG}" | awk 'NF' | fzf --multi)
    for file in "${files_to_revert[@]}"; do
      file_name="${file%%: *}"
      if [[ -f "${DUMP_DIR}/${file_name}" ]] || [[ -d "${DUMP_DIR}/${file_name}" ]]; then
        mv -v "${DUMP_DIR}"/"${file_name}" "${file##*: }"
        sed -i '' "s|${file}||g" "${DUMP_LOG}"
        sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
      fi
    done
  else
    while IFS= read -r line; do
      file_name="${line%%: *}"
      if [[ -f "${DUMP_DIR}/${file_name}" ]] || [[ -d "${DUMP_DIR}/${file_name}" ]]; then
        [[ -z "${file_to_revert}" ]] && \
          file_to_revert="${line}" || \
          files_removed+=("${line}")
      fi
    done < <(tac "${DUMP_LOG}")
    [[ -z "${confirm}" ]] && \
      confirm=$(get_confirm "regret: ${file_to_revert}?")
    [[ "${confirm}" != 'y' ]] && exit 1
    printf "%s\n" "${files_removed[@]}" | tac > "${DUMP_LOG}"
    [[ -n "${file_to_revert}" ]] && \
      mv -v "${DUMP_DIR}/${file_to_revert%%: *}" "${file_to_revert##*: }"
    sed -i '' '/^[[:space:]]*$/d' "${DUMP_LOG}"
  fi
}

action_comand="put"
case $1 in
  --put|-p)
    action_comand="put"
    shift
    ;;
  --clean|-c)
    action_comand="clean"
    shift
    ;;
  --regret|-r)
    action_comand='regret'
    shift
    ;;
  --log|-l)
    action_comand='log'
    shift
    ;;
esac

eval "${action_comand}" "$*"
